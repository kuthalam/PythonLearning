<html>
	<head>
		<title>The Rules of Python as I Understand Them</title>
	</head>
	<body>
		<b>Warning: All written assuming Java knowledge.</b>
		<h1> The Rules of Python as I Understand Them </h1>
		<br>
		<h2> The Basics </h2>
		<ul>
		<li>To print to the console: print "Hello, Python!"</li>
		<li>Here's an if, else statement:
			<ul>
			<li>if (True):
        			<ul>
				<li>#do something</li>
				</ul>
			</li>
			<li>elif (False):
				<ul>
				<li>#do other thing</li>
				</ul>
			</li>
			</ul>
		</li>
		<li>Anywhere from one to three quotes can be used for strings, but 3 is usually for multi-line strings
			<ul>
			<li>word = 'word'; sentence = "This is a sentence"</li>
    			<li>multiLine = """I'm gonna span<br>
                 	multiple lines"""</li>
			</ul>
		</li>
		<li>And in case you haven't noticed yet, the (#) is for comment. But you already knew that.</li>
		<li>import sys for basic I/O</li>
		<li>Oh, the most irritating thing of all: NO SEMICOLON. New lines mark the end of statements, and semicolons exist only for the sake of a series of statements
		on the same line</li>
		<li>Here's a close second though: NO BRACES. A block of code is denoted by tabs (you probably noticed) and
		the block (suite) starts with a colon after the header line (Ex. if(condition), while(condition)). See my if statement above for an example.</li>
		<li>Also, "else if" is "elif" in Python.</li>
		</ul><br>

		<h2>Variables</h2>
		<ul>
		<li>Explicit declaration for variables is unnecessary
			<ul>
			<li>Ex: count = 10; name = "Mark"</li>
			<li>Believe it or not, you can even do this: count, name = 10, "Mark" (Imo, Do yourself a favor and just don't)</li>
			</ul>
		</li>
		<li>Variable names are references - meaning you can delete these references (Ex. del count) </li>
		</ul>

		<h2>Data Types</h2>
		<ul>
		<li>Overall types: Numbers, String, List, Tuple, Dictionary
			<ul>
			<li>Numbers subtypes: int, long (Use L to denote this), float, complex (yes, I mean like 4 + 5j)</li>
			</ul>
		</li>
		<li>Finally, something familiar: Strings are like arrays
			<ul>
			<li>print str #print whole string</li>
			<li>print str[0] #print the first char</li>
			<li>print str[2:5] #print characters 3 to 5</li>
			<li>print str * 2 #print string twice</li>
			<li>Yes, + is concatenation</li>
			</ul>
		</li>
		<li>Lists work pretty much the same way
			<ul>
			<li>list = ['Multiple', 10, 'data', 100.7, 'types', 1000.5, 'allowed']</li>
			</ul>
		</li>
		<li>While lists are dynamic (like Arraylists), tuples are not. They are VERY static. Can't change the elements, nor the size. They're like Read-Only Lists
			<ul>
			<li>tuple = ("Oh", 10, "and", 100.5, "use", 1000.6, "parentheses")</li>
			</ul>
		</li>
		<li>Dictionaries are like hash tables and can be just about any type, but are usually numbers and/or strings
			<ul>
			<li>tinydict = {'key':'value', 'one': 1, 'ECE': 'Enjoyable torture'}</li>
			</ul>
		</li>
		<li>Plenty of functions for converting between data types, but you're not expecting me to list those, right?</li>
		</ul>

		<h2>Operators</h2>
		<ul>
		<li>Arithmetic operators are supported, but here are a couple new ones: ** for exponent and // for "floor division"
			<ul>
			<li>10**20 is "10 to the power of 20"</li>
			<li>// works a little strangely. If you're dividing postive numbers, divide and drop the fractional part. But if you're throwing a negative, the
			result is floored (rounded toward negative infinity)</li>
			<li>9//2 = 4, and -11/3 = -4 (TODO: Come up with a "floored" example later)</li>
			</ul>
		</li>
		<li>Comparison operators work like normal, thank God</li>
		<li>Yes, you can combine arithmetic and assignment operators (Ex. += or **=)</li>
		<li>Bitwise operators are also supported (&, ||, ^, ~, <<, and >>)</li>
		<li>We also have membership and identity operators
			<ul>
			<li>Let a sequence be a string, tuple, or list</li>
			<li>Then x in y returns true if x is a part of the sequence y. Naturally, "not in" is also a membership operator</li>
			<li>For identity operators, we have "is" and "is not"; if x is y returns true, x and y point to the same object</li>
			</ul>
		</li>
		</ul>

		<h2>Decision Making</h2>
		<ul>
		<li><b>Any non-zero and non-null values are true</b></li>
		<li>Loops work the usual way, but in addition to break and continue, we also now have pass
			<ul>
			<li>You include a pass statement if you don't want a piece of code to execute. This would be very useful for situations where you need a stub.</li>
			<li>Or you might need to include something before you can compile a piece of code, but don't know what to write. Just include a pass in that case.</li>
			</ul>
		</li>

		<h2>More on Data Types</h2>
		<h3>Numbers</h3>
		<ul>
		<li>Number objects are immutable.</li>
		<li>For explicit conversion, we have functions like int(x), long(x), float(x), complex(x), complex(x,y)</li>
		<li>There are a bunch of functions you can use for messing with numbers (mathematical, random, trig), but I'll let you look those up</li>
		</ul>

		<h3>Strings</h3>
		<li>Python has operators for formatting strings and has operators for making String manipulation and usage a little cleaner</li>
		<li>You can produce raw strings and unicode strings as well.</li>
		<li>If a string is surrounded by 3 single or double quotes, then any new lines within the variable will show up when the variable is printed.
			<ul>
			<li>So triple quotes are specifically for multi-line strings</li>
			</ul>
		</li>
		<li>There are also some functions for manipulating strings</li>
		</ul>

		<h3>Lists</h3>
		<ul>
		<li>Here's an example of one:
			<ul>
			<li>list = ['hello', 'this', 'list', 4, 500]</li>
			<li>list[0] accesses the first element</li>
			<li>list[1:3] accesses 'this' and 'list'</li>
			</ul>
		</li>
		<li>You can update lists by assigning values to a slice or a single slot</li>
		<li>Delete works similarly</li>
		<li>For indexing, you can use list[-x] where x is a positive number (now count left from the first element and loop around if needed)</li>
		<li>A bunch of functions are available for lists</li>
		</ul>

		<h3>Tuples</h3>
		<ul>
		<li>Another example:
			<ul>
			<li>tup1 = ('Ruby', 'Weiss', 'Blake', 'Yang')</li>
			<li>For a one element tuple: tup = (100,)</li>
			</ul>
		</li>
		<li>You cannot update tuples, but you can take portions of them to form new tuples:
			<ul>
			<li>tup2 = ("RWBY",)</li>
			<li>tup3 = tup1(0, 2) + tup2</li>
			<li>tup3 = ('Ruby', 'Weiss', "RWBY")</li>
			</ul>
		</li>
		<li>Naturally, you cannot delete specific values in a tuple either</li>
		<li>Everything else is pretty similar to Lists</li>
		</ul>

		<h3>Dictionaries</h3>
		<ul>
		<li>One more example:
			<ul>
			<li>dict = {'Name' : 'Ruby', 'Weapon' : 'Scythe', 'Age' : 16}</li>
			<li>print "dict['Name']: ", dict['Name'] => dict['Name']: Ruby</li>
			</ul>
		</li>
		<li>You can update existing key-value pairs or add new ones (Ex. dict['Semblance'] = 'Speed' =>
			dict = {'Name' : 'Ruby', 'Weapon' : 'Scythe', 'Age' : 16, 'Semblance' : 'Speed'}</li>
		<li>You can delete elements or the entire dictionary using del</li>
		<li>Some extra things to remember:
			<ul>
			<li>If you run into duplicate keys in a dictionary, the last occurence of (most recent assignment to) that key is what is used</li>
			<li>Keys are immutable, so only strings, numbers, and tuples can be used as keys</li>
			</ul>
		</li>
		<li>There are library functions for dictionaries of course</li>

		<h2>Miscellaneous</h2>
		</ul>
	</body>
</html>
